{"ast":null,"code":"var MACHINE_ID = Math.floor(Math.random() * 0xFFFFFF);\nvar index = ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);\nvar pid = (typeof process === 'undefined' || typeof process.pid !== 'number' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;\n/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n */\n\nvar isBuffer = function (obj) {\n  return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj));\n}; // Precomputed hex table enables speedy hex string conversion\n\n\nvar hexTable = [];\n\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n} // Regular expression that checks for hex value\n\n\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$'); // Lookup tables\n\nvar decodeLookup = [];\ni = 0;\n\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\n\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n/**\n * Create a new immutable ObjectID instance\n *\n * @class Represents the BSON ObjectID type\n * @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n * @return {Object} instance of ObjectID.\n */\n\n\nfunction ObjectID(id) {\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\n  if (id && (id instanceof ObjectID || id._bsontype === \"ObjectID\")) return id;\n  this._bsontype = 'ObjectID'; // The most common usecase (blank id, new objectId instance)\n\n  if (id == null || typeof id === 'number') {\n    // Generate a new id\n    this.id = this.generate(id); // Return the object\n\n    return;\n  } // Check if the passed in id is valid\n\n\n  var valid = ObjectID.isValid(id); // Throw an error if it's not a valid setup\n\n  if (!valid && id != null) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } else if (valid && typeof id === 'string' && id.length === 24) {\n    return ObjectID.createFromHexString(id);\n  } else if (id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if (id != null && typeof id.toHexString === 'function') {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  }\n}\n\nmodule.exports = ObjectID;\nObjectID.default = ObjectID;\n/**\n * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n *\n * @param {Number} time an integer number representing a number of seconds.\n * @return {ObjectID} return the created ObjectID\n * @api public\n */\n\nObjectID.createFromTime = function (time) {\n  time = parseInt(time, 10) % 0xFFFFFFFF;\n  return new ObjectID(hex(8, time) + \"0000000000000000\");\n};\n/**\n * Creates an ObjectID from a hex string representation of an ObjectID.\n *\n * @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.\n * @return {ObjectID} return the created ObjectID\n * @api public\n */\n\n\nObjectID.createFromHexString = function (hexString) {\n  // Throw an error if it's not a valid setup\n  if (typeof hexString === 'undefined' || hexString != null && hexString.length !== 24) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } // Calculate lengths\n\n\n  var data = '';\n  var i = 0;\n\n  while (i < 24) {\n    data += String.fromCharCode(decodeLookup[hexString.charCodeAt(i++)] << 4 | decodeLookup[hexString.charCodeAt(i++)]);\n  }\n\n  return new ObjectID(data);\n};\n/**\n * Checks if a value is a valid bson ObjectId\n *\n * @param {String} objectid Can be a 24 byte hex string or an instance of ObjectID.\n * @return {Boolean} return true if the value is a valid bson ObjectID, return false otherwise.\n * @api public\n *\n * THE NATIVE DOCUMENTATION ISN'T CLEAR ON THIS GUY!\n * http://mongodb.github.io/node-mongodb-native/api-bson-generated/objectid.html#objectid-isvalid\n */\n\n\nObjectID.isValid = function (id) {\n  if (id == null) return false;\n\n  if (typeof id === 'number') {\n    return true;\n  }\n\n  if (typeof id === 'string') {\n    return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);\n  }\n\n  if (id instanceof ObjectID) {\n    return true;\n  }\n\n  if (isBuffer(id)) {\n    return true;\n  } // Duck-Typing detection of ObjectId like objects\n\n\n  if (typeof id.toHexString === 'function' && (id.id instanceof _Buffer || typeof id.id === 'string')) {\n    return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);\n  }\n\n  return false;\n};\n\nObjectID.prototype = {\n  constructor: ObjectID,\n\n  /**\n   * Return the ObjectID id as a 24 byte hex string representation\n   *\n   * @return {String} return the 24 byte hex string representation.\n   * @api public\n   */\n  toHexString: function () {\n    if (!this.id || !this.id.length) {\n      throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');\n    }\n\n    if (this.id.length === 24) {\n      return this.id;\n    }\n\n    if (isBuffer(this.id)) {\n      return this.id.toString('hex');\n    }\n\n    var hexString = '';\n\n    for (var i = 0; i < this.id.length; i++) {\n      hexString += hexTable[this.id.charCodeAt(i)];\n    }\n\n    return hexString;\n  },\n\n  /**\n   * Compares the equality of this ObjectID with `otherID`.\n   *\n   * @param {Object} otherId ObjectID instance to compare against.\n   * @return {Boolean} the result of comparing two ObjectID's\n   * @api public\n   */\n  equals: function (otherId) {\n    if (otherId instanceof ObjectID) {\n      return this.toString() === otherId.toString();\n    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12 && isBuffer(this.id)) {\n      return otherId === this.id.toString('binary');\n    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {\n      return otherId.toLowerCase() === this.toHexString();\n    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {\n      return otherId === this.id;\n    } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n      return otherId.toHexString() === this.toHexString();\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Returns the generation date (accurate up to the second) that this ID was generated.\n   *\n   * @return {Date} the generation date\n   * @api public\n   */\n  getTimestamp: function () {\n    var timestamp = new Date();\n    var time;\n\n    if (isBuffer(this.id)) {\n      time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n    } else {\n      time = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24;\n    }\n\n    timestamp.setTime(Math.floor(time) * 1000);\n    return timestamp;\n  },\n\n  /**\n  * Generate a 12 byte id buffer used in ObjectID's\n  *\n  * @method\n  * @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n  * @return {string} return the 12 byte id buffer string.\n  */\n  generate: function (time) {\n    if ('number' !== typeof time) {\n      time = ~~(Date.now() / 1000);\n    } //keep it in the ring!\n\n\n    time = parseInt(time, 10) % 0xFFFFFFFF;\n    var inc = next();\n    return String.fromCharCode(time >> 24 & 0xFF, time >> 16 & 0xFF, time >> 8 & 0xFF, time & 0xFF, MACHINE_ID >> 16 & 0xFF, MACHINE_ID >> 8 & 0xFF, MACHINE_ID & 0xFF, pid >> 8 & 0xFF, pid & 0xFF, inc >> 16 & 0xFF, inc >> 8 & 0xFF, inc & 0xFF);\n  }\n};\n\nfunction next() {\n  return index = (index + 1) % 0xFFFFFF;\n}\n\nfunction hex(length, n) {\n  n = n.toString(16);\n  return n.length === length ? n : \"00000000\".substring(n.length, length) + n;\n}\n\nfunction buffer(str) {\n  var i = 0,\n      out = [];\n  if (str.length === 24) for (; i < 24; out.push(parseInt(str[i] + str[i + 1], 16)), i += 2);else if (str.length === 12) for (; i < 12; out.push(str.charCodeAt(i)), i++);\n  return out;\n}\n\nvar inspect = Symbol && Symbol.for && Symbol.for('nodejs.util.inspect.custom') || 'inspect';\n/**\n * Converts to a string representation of this Id.\n *\n * @return {String} return the 24 byte hex string representation.\n * @api private\n */\n\nObjectID.prototype[inspect] = function () {\n  return \"ObjectID(\" + this + \")\";\n};\n\nObjectID.prototype.toJSON = ObjectID.prototype.toHexString;\nObjectID.prototype.toString = ObjectID.prototype.toHexString;","map":null,"metadata":{},"sourceType":"script"}